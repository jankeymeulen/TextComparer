package e.util;

import java.util.regex.*;
import org.jessies.test.*;

/**
 * A rewriter does a global substitution in the strings passed to its
 * 'rewrite' method. It uses the pattern supplied to its constructor,
 * and is like 'String.replaceAll' except for the fact that its
 * replacement strings are generated by invoking a method you write,
 * rather than from another string.
 *
 * This class is supposed to be equivalent to Ruby's 'gsub' when given
 * a block. This is the nicest syntax I've managed to come up with in
 * Java so far. It's not too bad, and might actually be preferable if
 * you want to do the same rewriting to a number of strings in the same
 * method or class.
 *
 * See the example 'main' for a sample of how to use this class.
 *
 * @author Elliott Hughes
 * @author Roger Millington
 */
public abstract class Rewriter {
    private Pattern pattern;
    private Matcher matcher;

    /**
     * Constructs a rewriter using the given regular expression;
     * the syntax is the same as for 'Pattern.compile'.
     */
    public Rewriter(String regularExpression) {
        this.pattern = Pattern.compile(regularExpression);
    }

    /**
     * Returns the input subsequence captured by the given group
     * during the previous match operation.
     */
    public String group(int i) {
        return matcher.group(i);
    }

    /**
     * Overridden to compute a replacement for each match. Use
     * the method 'group' to access the captured groups.
     */
    public abstract String replacement();

    /**
     * Returns the result of rewriting 'original' by invoking the method 'replacement' for each match of the regular expression supplied to the constructor.
     */
    public String rewrite(CharSequence original) {
        return rewrite(original, new StringBuffer(original.length())).toString();
    }
    
    /**
     * Returns the result of appending the rewritten 'original' to 'destination'.
     * We have to use StringBuffer rather than the more obvious and general Appendable because of Matcher's interface (Sun bug 5066679).
     * Most users will prefer the single-argument rewrite, which supplies a temporary StringBuffer itself.
     */
    public StringBuffer rewrite(CharSequence original, StringBuffer destination) {
        this.matcher = pattern.matcher(original);
        while (matcher.find()) {
            matcher.appendReplacement(destination, "");
            destination.append(replacement());
        }
        matcher.appendTail(destination);
        return destination;
    }
    
    @Test private static void testInches() {
        // Rewrite an ancient unit of length in SI units.
        String result = new Rewriter("([0-9]+(\\.[0-9]+)?)[- ]?(inch(es)?)") {
            public String replacement() {
                float inches = Float.parseFloat(group(1));
                return Float.toString(2.54f * inches) + " cm";
            }
        }.rewrite("a 17 inch display");
        Assert.equals(result, "a 43.18 cm display");
    }
    
    @Test private static void testAlmanac() {
        // The "Searching and Replacing with Non-Constant Values Using a
        // Regular Expression" example from the Java Almanac.
        String result = new Rewriter("([a-zA-Z]+[0-9]+)") {
            public String replacement() {
                return group(1).toUpperCase();
            }
        }.rewrite("ab12 cd efg34");
        Assert.equals(result, "AB12 cd EFG34");
    }
    
    @Test private static void testDollars() {
        String result = new Rewriter("([0-9]+) US cents") {
            public String replacement() {
                long dollars = Long.parseLong(group(1))/100;
                return "$" + dollars;
            }
        }.rewrite("5000 US cents");
        Assert.equals(result, "$50");
    }
    
    @Test private static void testMilliseconds() {
        // Rewrite durations in milliseconds in ISO 8601 format.
        String result = new Rewriter("(\\d+)\\s*ms") {
            public String replacement() {
                long milliseconds = Long.parseLong(group(1));
                return TimeUtilities.msToIsoString(milliseconds);
            }
        }.rewrite("232341243 ms");
        Assert.equals(result, "P64H32M21.243S");
    }
}
